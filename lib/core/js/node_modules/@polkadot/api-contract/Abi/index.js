import _classPrivateFieldLooseBase from "@babel/runtime/helpers/esm/classPrivateFieldLooseBase";
import _classPrivateFieldLooseKey from "@babel/runtime/helpers/esm/classPrivateFieldLooseKey";
// Copyright 2017-2021 @polkadot/api-contract authors & contributors
// SPDX-License-Identifier: Apache-2.0
import { TypeDefInfo, TypeRegistry } from '@polkadot/types';
import { assert, assertReturn, compactAddLength, compactStripLength, isNumber, isObject, isString, logger, stringCamelCase, stringify, u8aConcat, u8aToHex } from '@polkadot/util';
import { v0ToLatest, v1ToLatest } from "./toLatest.js";
const l = logger('Abi');
const PRIMITIVE_ALWAYS = ['AccountId', 'AccountIndex', 'Address', 'Balance'];

function findMessage(list, messageOrId) {
  const message = isNumber(messageOrId) ? list[messageOrId] : isString(messageOrId) ? list.find(({
    identifier
  }) => [identifier, stringCamelCase(identifier)].includes(messageOrId.toString())) : messageOrId;
  return assertReturn(message, () => `Attempted to call an invalid contract interface, ${stringify(messageOrId)}`);
} // FIXME: This is still workable with V0, V1 & V2, but certainly is not a scalable
// approach (right at this point don't quite have better ideas that is not as complex
// as the conversion tactics in the runtime Metadata)


function getLatestMeta(registry, json) {
  const metadata = registry.createType('ContractMetadata', isObject(json.V2) ? {
    V2: json.V2
  } : isObject(json.V1) ? {
    V1: json.V1
  } : {
    V0: json
  });
  return metadata.isV2 ? metadata.asV2 : metadata.isV1 ? v1ToLatest(registry, metadata.asV1) : v0ToLatest(registry, metadata.asV0);
}

function parseJson(json, chainProperties) {
  const registry = new TypeRegistry();
  const info = registry.createType('ContractProjectInfo', json);
  const latest = getLatestMeta(registry, json);
  const lookup = registry.createType('PortableRegistry', {
    types: latest.types
  }); // attach the lookup to the registry - now the types are known

  registry.setLookup(lookup);

  if (chainProperties) {
    registry.setChainProperties(chainProperties);
  } // warm-up the actual type, pre-use


  lookup.types.forEach(({
    id
  }) => lookup.getTypeDef(id));
  return [json, registry, latest, info];
}

var _createArgs = /*#__PURE__*/_classPrivateFieldLooseKey("createArgs");

var _createEvent = /*#__PURE__*/_classPrivateFieldLooseKey("createEvent");

var _createMessage = /*#__PURE__*/_classPrivateFieldLooseKey("createMessage");

var _decodeArgs = /*#__PURE__*/_classPrivateFieldLooseKey("decodeArgs");

var _decodeMessage = /*#__PURE__*/_classPrivateFieldLooseKey("decodeMessage");

var _encodeArgs = /*#__PURE__*/_classPrivateFieldLooseKey("encodeArgs");

export class Abi {
  constructor(abiJson, chainProperties) {
    this.events = void 0;
    this.constructors = void 0;
    this.info = void 0;
    this.json = void 0;
    this.messages = void 0;
    this.metadata = void 0;
    this.registry = void 0;
    Object.defineProperty(this, _createArgs, {
      writable: true,
      value: (args, spec) => {
        return args.map(({
          label,
          type
        }, index) => {
          try {
            assert(isObject(type), 'Invalid type definition found');
            const displayName = type.displayName.length ? type.displayName[type.displayName.length - 1].toString() : undefined;
            const camelName = stringCamelCase(label);

            if (displayName && PRIMITIVE_ALWAYS.includes(displayName)) {
              return {
                name: camelName,
                type: {
                  info: TypeDefInfo.Plain,
                  type: displayName
                }
              };
            }

            const typeDef = this.registry.lookup.getTypeDef(type.type);
            return {
              name: camelName,
              type: displayName && !typeDef.type.startsWith(displayName) ? {
                displayName,
                ...typeDef
              } : typeDef
            };
          } catch (error) {
            l.error(`Error expanding argument ${index} in ${stringify(spec)}`);
            throw error;
          }
        });
      }
    });
    Object.defineProperty(this, _createEvent, {
      writable: true,
      value: (spec, index) => {
        const args = _classPrivateFieldLooseBase(this, _createArgs)[_createArgs](spec.args, spec);

        const event = {
          args,
          docs: spec.docs.map(d => d.toString()),
          fromU8a: data => ({
            args: _classPrivateFieldLooseBase(this, _decodeArgs)[_decodeArgs](args, data),
            event
          }),
          identifier: spec.label.toString(),
          index
        };
        return event;
      }
    });
    Object.defineProperty(this, _createMessage, {
      writable: true,
      value: (spec, index, add = {}) => {
        const args = _classPrivateFieldLooseBase(this, _createArgs)[_createArgs](spec.args, spec);

        const identifier = spec.label.toString();
        const message = { ...add,
          args,
          docs: spec.docs.map(d => d.toString()),
          fromU8a: data => ({
            args: _classPrivateFieldLooseBase(this, _decodeArgs)[_decodeArgs](args, data),
            message
          }),
          identifier,
          index,
          method: stringCamelCase(identifier),
          selector: spec.selector,
          toU8a: params => _classPrivateFieldLooseBase(this, _encodeArgs)[_encodeArgs](spec, args, params)
        };
        return message;
      }
    });
    Object.defineProperty(this, _decodeArgs, {
      writable: true,
      value: (args, data) => {
        // for decoding we expect the input to be just the arg data, no selectors
        // no length added (this allows use with events as well)
        let offset = 0;
        return args.map(({
          type: {
            lookupName,
            type
          }
        }) => {
          const value = this.registry.createType(lookupName || type, data.subarray(offset));
          offset += value.encodedLength;
          return value;
        });
      }
    });
    Object.defineProperty(this, _decodeMessage, {
      writable: true,
      value: (type, list, data) => {
        const [, trimmed] = compactStripLength(data);
        const selector = trimmed.subarray(0, 4);
        const message = list.find(m => m.selector.eq(selector));
        assert(message, `Unable to find ${type} with selector ${u8aToHex(selector)}`);
        return message.fromU8a(trimmed.subarray(4));
      }
    });
    Object.defineProperty(this, _encodeArgs, {
      writable: true,
      value: ({
        label,
        selector
      }, args, data) => {
        assert(data.length === args.length, () => `Expected ${args.length} arguments to contract message '${label.toString()}', found ${data.length}`);
        return compactAddLength(u8aConcat(this.registry.createType('ContractSelector', selector).toU8a(), ...args.map(({
          type: {
            lookupName,
            type
          }
        }, index) => this.registry.createType(lookupName || type, data[index]).toU8a())));
      }
    });
    [this.json, this.registry, this.metadata, this.info] = parseJson(isString(abiJson) ? JSON.parse(abiJson) : abiJson, chainProperties);
    this.constructors = this.metadata.spec.constructors.map((spec, index) => _classPrivateFieldLooseBase(this, _createMessage)[_createMessage](spec, index, {
      isConstructor: true
    }));
    this.events = this.metadata.spec.events.map((spec, index) => _classPrivateFieldLooseBase(this, _createEvent)[_createEvent](spec, index));
    this.messages = this.metadata.spec.messages.map((spec, index) => {
      const typeSpec = spec.returnType.unwrapOr(null);
      return _classPrivateFieldLooseBase(this, _createMessage)[_createMessage](spec, index, {
        isMutating: spec.mutates.isTrue,
        isPayable: spec.payable.isTrue,
        returnType: typeSpec ? this.registry.lookup.getTypeDef(typeSpec.type) : null
      });
    });
  }
  /**
   * Warning: Unstable API, bound to change
   */


  decodeEvent(data) {
    const index = data[0];
    const event = this.events[index];
    assert(event, () => `Unable to find event with index ${index}`);
    return event.fromU8a(data.subarray(1));
  }
  /**
   * Warning: Unstable API, bound to change
   */


  decodeConstructor(data) {
    return _classPrivateFieldLooseBase(this, _decodeMessage)[_decodeMessage]('message', this.constructors, data);
  }
  /**
   * Warning: Unstable API, bound to change
   */


  decodeMessage(data) {
    return _classPrivateFieldLooseBase(this, _decodeMessage)[_decodeMessage]('message', this.messages, data);
  }

  findConstructor(constructorOrId) {
    return findMessage(this.constructors, constructorOrId);
  }

  findMessage(messageOrId) {
    return findMessage(this.messages, messageOrId);
  }

}